TinyPreprocessor Project Plan:

Phase 1 - Project Setup:
  Phase 1.1 - Architectural Documentation:
    ✔ Create docs/ folder at workspace root @done(26-01-08 19:39)
    ✔ Document Core abstractions architecture (ResourceId, IResource, IDirective, IResourceResolver, IDirectiveParser) @done(26-01-08 19:39)
    ✔ Document Diagnostics system architecture (severity levels, diagnostic types, collection) @done(26-01-08 19:39)
    ✔ Document Dependency Graph architecture (Graffs integration, cycle detection, topological sorting) @done(26-01-08 19:39)
    ✔ Document Source Mapping architecture (positions, spans, mappings, query system) @done(26-01-08 19:39)
    ✔ Document Merge System architecture (strategies, context, directive stripping) @done(26-01-08 19:39)
    ✔ Document Preprocessor orchestrator architecture (processing flow, caching, options) @done(26-01-08 19:39)
  Phase 1.2 - Solution Structure:
    ✔ Create TinyPreprocessor.sln at workspace root @done(26-01-07 18:15)
    ✔ Create src/TinyPreprocessor/TinyPreprocessor.csproj (net8.0, nullable enabled) @done(26-01-07 18:15)
  ✔ Add PackageReference to Graffs 0.1.0 @done(26-01-08 19:45)
  ✔ Create tests/TinyPreprocessor.Tests/TinyPreprocessor.Tests.csproj @done(26-01-08 19:46)
  ✔ Add xUnit and Moq package references to test project @done(26-01-08 19:46)
  ✔ Add project reference from test project to main library @done(26-01-08 19:46)

Phase 2 - Core Abstractions (src/TinyPreprocessor/Core/):
  ✔ Create ResourceId readonly struct @done(26-01-08 20:00)
    ✔ Wrap string Path property @done(26-01-08 20:00)
    ✔ Implement IEquatable<ResourceId> @done(26-01-08 20:00)
    ✔ Override GetHashCode() and Equals() @done(26-01-08 20:00)
    ✔ Add implicit/explicit conversion operators @done(26-01-08 20:00)
  ✔ Create IResource interface @done(26-01-08 20:00)
    ✔ ResourceId Id property @done(26-01-08 20:00)
    ✔ ReadOnlyMemory<char> Content property @done(26-01-08 20:00)
    ✔ IReadOnlyDictionary<string, object>? Metadata property @done(26-01-08 20:00)
  ✔ Create Resource sealed record implementing IResource @done(26-01-08 20:00)
  ✔ Create IDirective marker interface @done(26-01-08 20:00)
    ✔ Range Location property @done(26-01-08 20:00)
  ✔ Create IResourceResolver interface @done(26-01-08 20:00)
    ✔ ValueTask<ResourceResolutionResult> ResolveAsync(string reference, IResource? relativeTo, CancellationToken ct) @done(26-01-08 20:00)
  ✔ Create ResourceResolutionResult record @done(26-01-08 20:00)
    ✔ IResource? Resource property @done(26-01-08 20:00)
    ✔ IPreprocessorDiagnostic? Error property @done(26-01-08 20:00)
  ✔ Create IDirectiveParser<TDirective> interface @done(26-01-08 20:00)
    ✔ IEnumerable<TDirective> Parse(ReadOnlyMemory<char> content, ResourceId resourceId) where TDirective : IDirective @done(26-01-08 20:00)

Phase 3 - Diagnostics System (src/TinyPreprocessor/Diagnostics/):
  ✔ Create DiagnosticSeverity enum (Info = 0, Warning = 1, Error = 2) @done(26-01-08 20:05)
  ✔ Create IPreprocessorDiagnostic interface @done(26-01-08 20:05)
    ✔ DiagnosticSeverity Severity property @done(26-01-08 20:05)
    ✔ string Code property @done(26-01-08 20:05)
    ✔ string Message property @done(26-01-08 20:05)
    ✔ ResourceId? Resource property @done(26-01-08 20:05)
    ✔ Range? Location property @done(26-01-08 20:05)
  ✔ Create CircularDependencyDiagnostic sealed record @done(26-01-08 20:05)
    ✔ Implement IPreprocessorDiagnostic @done(26-01-08 20:05)
    ✔ IReadOnlyList<ResourceId> Cycle property @done(26-01-08 20:05)
    ✔ Code = "TPP0001" @done(26-01-08 20:05)
  ✔ Create ResolutionFailedDiagnostic sealed record @done(26-01-08 20:05)
    ✔ Implement IPreprocessorDiagnostic @done(26-01-08 20:05)
    ✔ string Reference property @done(26-01-08 20:05)
    ✔ Code = "TPP0002" @done(26-01-08 20:05)
  ✔ Create ParseErrorDiagnostic sealed record @done(26-01-08 20:05)
    ✔ Implement IPreprocessorDiagnostic @done(26-01-08 20:05)
    ✔ Code = "TPP0003" @done(26-01-08 20:05)
  ✔ Create DiagnosticCollection sealed class @done(26-01-08 20:05)
    ✔ Thread-safe with lock @done(26-01-08 20:05)
    ✔ void Add(IPreprocessorDiagnostic) method @done(26-01-08 20:05)
    ✔ bool HasErrors property @done(26-01-08 20:05)
    ✔ Implement IReadOnlyCollection<IPreprocessorDiagnostic> @done(26-01-08 20:05)

Phase 4 - Dependency Graph Layer (src/TinyPreprocessor/Graph/):
  ☐ Create ResourceDependencyGraph sealed class
    ☐ Internal DependencyGraphBuilder<ResourceId> field
    ☐ void AddResource(ResourceId id) method
    ☐ void AddDependency(ResourceId dependent, ResourceId dependency) method
    ☐ IReadOnlyList<IReadOnlyList<ResourceId>> DetectCycles() method using CycleDetection.FindAllCycles()
    ☐ IReadOnlyList<ResourceId> GetProcessingOrder() method using TopologicalSort.KahnSort()

Phase 5 - Source Mapping System (src/TinyPreprocessor/SourceMaps/):
  ☐ Create SourcePosition readonly struct
    ☐ int Line property (0-based)
    ☐ int Column property (0-based)
    ☐ Implement IComparable<SourcePosition>
    ☐ Implement IEquatable<SourcePosition>
  ☐ Create SourceSpan readonly struct
    ☐ SourcePosition Start property
    ☐ SourcePosition End property
  ☐ Create SourceMapping sealed record
    ☐ SourceSpan GeneratedSpan property
    ☐ ResourceId OriginalResource property
    ☐ SourceSpan OriginalSpan property
  ☐ Create SourceLocation sealed record
    ☐ ResourceId Resource property
    ☐ SourcePosition OriginalPosition property
  ☐ Create SourceMap sealed class
    ☐ IReadOnlyList<SourceMapping> Mappings property (sorted by generated position)
    ☐ SourceLocation? Query(SourcePosition generatedPosition) method with binary search
  ☐ Create SourceMapBuilder sealed class
    ☐ Internal List<SourceMapping> for accumulation
    ☐ void AddMapping(SourceMapping) method
    ☐ void AddSegment(ResourceId resource, SourceSpan generated, SourceSpan original) method
    ☐ SourceMap Build() method (sorts and returns immutable)

Phase 6 - Merge System (src/TinyPreprocessor/Merging/):
  ☐ Create ResolvedResource sealed record
    ☐ IResource Resource property
    ☐ IReadOnlyList<IDirective> Directives property
  ☐ Create MergeContext sealed class
    ☐ SourceMapBuilder SourceMapBuilder property
    ☐ DiagnosticCollection Diagnostics property
    ☐ IReadOnlyDictionary<ResourceId, IResource> ResolvedCache property
  ☐ Create IMergeStrategy<TContext> interface
    ☐ ReadOnlyMemory<char> Merge(IReadOnlyList<ResolvedResource> orderedResources, TContext userContext, MergeContext context)
  ☐ Create ConcatenatingMergeStrategy<TContext> sealed class
    ☐ Implement IMergeStrategy<TContext>
    ☐ Iterate resources in topological order
    ☐ Strip directive ranges from content
    ☐ Append to StringBuilder
    ☐ Record mappings via MergeContext.SourceMapBuilder

Phase 7 - Main Orchestrator (src/TinyPreprocessor/):
  ☐ Create PreprocessorOptions sealed record
    ☐ bool DeduplicateIncludes = true
    ☐ int MaxIncludeDepth = 100
  ☐ Create PreprocessResult sealed record
    ☐ ReadOnlyMemory<char> Content property
    ☐ SourceMap SourceMap property
    ☐ DiagnosticCollection Diagnostics property
    ☐ bool Success => !Diagnostics.HasErrors
  ☐ Create Preprocessor<TDirective, TContext> sealed class
    ☐ Constructor accepting IDirectiveParser<TDirective>, IResourceResolver, IMergeStrategy<TContext>
    ☐ Internal per-call cache Dictionary<ResourceId, ResolvedResource>
    ☐ ValueTask<PreprocessResult> ProcessAsync(IResource root, TContext context, PreprocessorOptions? options, CancellationToken ct)
    ☐ Implement recursive resolution with depth tracking
    ☐ Implement deduplication logic based on options
    ☐ Wire up cycle detection → CircularDependencyDiagnostic
    ☐ Wire up topological sorting
    ☐ Wire up merge strategy invocation
    ☐ Build final PreprocessResult

Phase 8 - Unit Tests (tests/TinyPreprocessor.Tests/):
  ☐ Core tests
    ☐ ResourceId equality and hashing tests
    ☐ Resource record tests
  ☐ Diagnostics tests
    ☐ DiagnosticCollection thread-safety tests
    ☐ HasErrors logic tests
  ☐ Graph tests
    ☐ Cycle detection with known circular graphs
    ☐ Topological sort ordering verification
    ☐ Empty graph edge cases
  ☐ SourceMap tests
    ☐ SourcePosition comparison tests
    ☐ SourceMapBuilder accumulation tests
    ☐ SourceMap.Query binary search tests
  ☐ Merge tests
    ☐ ConcatenatingMergeStrategy output verification
    ☐ Directive stripping tests
    ☐ Source mapping accuracy tests
  ☐ Integration tests
    ☐ Full preprocessing pipeline with mock resolver/parser
    ☐ Circular dependency handling (continues with diagnostics)
    ☐ Deduplication behavior
    ☐ MaxIncludeDepth enforcement
