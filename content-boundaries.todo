```todo
Content Boundaries + Preprocessor Configuration Plan:

Phase 1 - PreprocessorConfiguration Refactor:
  Phase 1.1 - New Configuration Type:
    ✔ Create TinyPreprocessor/PreprocessorConfiguration.cs
    ✔ Add `public sealed record class PreprocessorConfiguration<TContent, TDirective, TContext>` (namespace: TinyPreprocessor)
    ✔ Include required collaborators as ctor params + init-only properties:
      ✔ IDirectiveParser<TContent, TDirective> DirectiveParser
      ✔ IDirectiveModel<TDirective> DirectiveModel
      ✔ IResourceResolver<TContent> ResourceResolver
      ✔ IMergeStrategy<TContent, TDirective, TContext> MergeStrategy
      ✔ IContentModel<TContent> ContentModel
    ✔ Validate non-null ctor args (throw ArgumentNullException)

  Phase 1.2 - Preprocessor Constructor Migration:
    ✔ Add `Preprocessor(PreprocessorConfiguration<TContent, TDirective, TContext> config)` constructor
    ✔ Keep existing 5-arg constructor as a forwarding wrapper
    ☐ (Optional) Mark 5-arg constructor as [Obsolete] with guidance string
    ✔ Ensure PreprocessAsync behavior remains unchanged (options still per-call)

  Phase 1.3 - Update Call Sites + Docs:
    ✔ Update TinyPreprocessor.Tests/Integration/PreprocessorIntegrationTests.cs to use PreprocessorConfiguration
    ✔ Update README.md quick-start construction example to use PreprocessorConfiguration
    ✔ Update docs/06-preprocessor-orchestrator.md construction example (currently out-of-date)

  Phase 1.4 - Verification:
    ✔ Run test suite (TinyPreprocessor.Tests)
    ✔ Ensure no public API regressions beyond the added config constructor

Phase 2 - Content Boundary Abstractions (Core):
  Phase 2.1 - Boundary Resolver Interfaces:
    ✔ Add TinyPreprocessor/Core/IContentBoundaryResolver.cs
    ✔ Define `IContentBoundaryResolver<TContent, TBoundary>` where TBoundary is a marker type
    ✔ Core behavior: query boundary offsets in a [startOffset, endOffset) range within a given content instance
    ✔ Choose range contract details:
      ✔ 0-based offsets
      ✔ inclusive/exclusive semantics documented
      ✔ ordering guaranteed (ascending)
      ✔ duplicates handled (allowed vs filtered)

  Phase 2.2 - Provider for Multiple Boundary Types:
    ✔ Add TinyPreprocessor/Core/IContentBoundaryResolverProvider.cs
    ✔ Define `bool TryGet<TContent, TBoundary>(out IContentBoundaryResolver<TContent, TBoundary> resolver)`
    ✔ Add an Empty provider implementation (Null Object), e.g. ContentBoundaryResolverProvider.Empty

  Phase 2.3 - Wire Provider into Configuration:
    ✔ Add `IContentBoundaryResolverProvider ContentBoundaryResolverProvider { get; }` to PreprocessorConfiguration
    ✔ Default to empty provider (no null checks required)

Phase 3 - SourceMap + Boundary Composition Utilities:
  Phase 3.1 - Decide Composition Surface:
    ☐ Add utility APIs (extension methods or helper types) that combine:
      ☐ SourceMap (offset mapping)
      ☐ IContentBoundaryResolver<TBoundary> (boundary offsets)
    ☐ Define intended “line number from offset” workflow using a boundary type (e.g., LineBoundary marker)

  Phase 3.2 - Implement Minimal Helpers:
    ☐ Add a helper to compute boundary index within range (e.g., count boundaries < offset)
    ☐ Support resolving both:
      ☐ Generated-offset boundary index
      ☐ Original-offset boundary index (via SourceMap GetSourceLocation)

  Phase 3.3 - Tests:
    ☐ Add unit tests for boundary range query integration
    ☐ Add unit tests for offset -> boundary-index (line number) computation

Phase 4 - Adoption in Text-Specific Features (Optional / Follow-up):
  Phase 4.1 - Replace Hard-Coded Newline Semantics:
    ☐ Update TinyPreprocessor/Text/NonWholeLineDirectiveDiagnostic.cs to use boundary provider/resolver (LineBoundary)
    ☐ Define expected behavior for CRLF / LF / custom newline sequences via downstream resolver

  Phase 4.2 - Documentation:
    ☐ Add docs describing boundary concepts and examples for line boundaries
    ☐ Update README source-mapping section to mention boundary-based line resolution

```